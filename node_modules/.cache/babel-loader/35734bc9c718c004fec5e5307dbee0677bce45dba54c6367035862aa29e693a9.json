{"ast":null,"code":"const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';\nconst SYSTEM_PROMPT = `You are an intelligent writing assistant helping users improve their own writing while retaining full control. Your job is to return specific, helpful editing suggestions in structured JSON format only.\n\nYou will receive a block of text. Carefully read and identify **well-justified improvements**, categorized by type:\n\nLEVEL 1 (Grammar):\n- Correct surface-level errors like typos, punctuation, subject-verb agreement, verb tense, and article usage.\n- Do NOT suggest stylistic changes at this level.\n- Be minimal and precise.\n\nLEVEL 2 (Cohesion / Sentence Structure):\n- Suggest improvements for clarity, sentence flow, and reducing awkward phrasing.\n- You may combine short, choppy sentences or split run-ons.\n- Do not rewrite large blocks; suggest small, local structural edits.\n\nLEVEL 3 (Content Suggestions):\n- Suggest additions, removals, or rephrasings to improve logic, persuasiveness, or support.\n- Do not invent content, but propose useful insertions (e.g., \"Add an example here.\" or \"This sentence is redundant.\")\n- Keep it concise and focused on meaning, not tone or style.\n\nReturn only a single JSON object with the key \\`\"suggestions\"\\` that maps to an array of suggestion objects.\n\nEach suggestion object must include:\n- \\`level\\`: 1, 2, or 3 (based on the categories above)\n- \\`start\\`: starting character index of the original substring (based on the exact input string, not tokens or words)\n- \\`end\\`: ending character index (exclusive)\n- \\`original\\`: the original substring in the text\n- \\`replacement\\`: your suggested alternative (optional for level 3)\n- \\`reason\\`: a short, clear explanation of the suggested improvement\n\nOutput **only** valid JSON. Do not include markdown, comments, or extra text.\n\nIf there are no issues, return:\n\\`\\`\\`json\n{ \"suggestions\": [] }\n\\`\\`\\``;\nexport const analyzeText = async (text, apiKey) => {\n  if (!apiKey) {\n    throw new Error('OpenAI API key is required');\n  }\n  try {\n    var _data$choices$, _data$choices$$messag;\n    const response = await fetch(OPENAI_API_URL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o',\n        messages: [{\n          role: 'system',\n          content: SYSTEM_PROMPT\n        }, {\n          role: 'user',\n          content: text\n        }],\n        temperature: 0.3,\n        response_format: {\n          type: 'json_object'\n        },\n        max_tokens: 10000\n      })\n    });\n    if (!response.ok) {\n      var _errorData$error;\n      const errorData = await response.json();\n      throw new Error(`OpenAI API error: ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || 'Unknown error'}`);\n    }\n    const data = await response.json();\n    if (data.choices[0].finish_reason === 'length') {\n      throw new Error('The response was truncated because it exceeded the maximum token limit. Please try a shorter text.');\n    }\n    const content = (_data$choices$ = data.choices[0]) === null || _data$choices$ === void 0 ? void 0 : (_data$choices$$messag = _data$choices$.message) === null || _data$choices$$messag === void 0 ? void 0 : _data$choices$$messag.content;\n    if (!content) {\n      throw new Error('No response content from OpenAI');\n    }\n\n    // Content can be already an object when using JSON mode\n    if (typeof content === 'object') {\n      return content;\n    }\n\n    // Fallback: try to parse string content\n    try {\n      const parsed = JSON.parse(content);\n      return parsed;\n    } catch (parseError) {\n      console.error('Failed to parse OpenAI response:', content);\n      throw new Error('Invalid JSON response from OpenAI');\n    }\n  } catch (error) {\n    console.error('Error calling OpenAI API:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["OPENAI_API_URL","SYSTEM_PROMPT","analyzeText","text","apiKey","Error","_data$choices$","_data$choices$$messag","response","fetch","method","headers","body","JSON","stringify","model","messages","role","content","temperature","response_format","type","max_tokens","ok","_errorData$error","errorData","json","error","message","data","choices","finish_reason","parsed","parse","parseError","console"],"sources":["/Users/thiagodonato/Documents/App_Projects/Edit_Text/src/api.ts"],"sourcesContent":["import { OpenAIResponse } from './types';\n\nconst OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';\n\nconst SYSTEM_PROMPT = `You are an intelligent writing assistant helping users improve their own writing while retaining full control. Your job is to return specific, helpful editing suggestions in structured JSON format only.\n\nYou will receive a block of text. Carefully read and identify **well-justified improvements**, categorized by type:\n\nLEVEL 1 (Grammar):\n- Correct surface-level errors like typos, punctuation, subject-verb agreement, verb tense, and article usage.\n- Do NOT suggest stylistic changes at this level.\n- Be minimal and precise.\n\nLEVEL 2 (Cohesion / Sentence Structure):\n- Suggest improvements for clarity, sentence flow, and reducing awkward phrasing.\n- You may combine short, choppy sentences or split run-ons.\n- Do not rewrite large blocks; suggest small, local structural edits.\n\nLEVEL 3 (Content Suggestions):\n- Suggest additions, removals, or rephrasings to improve logic, persuasiveness, or support.\n- Do not invent content, but propose useful insertions (e.g., \"Add an example here.\" or \"This sentence is redundant.\")\n- Keep it concise and focused on meaning, not tone or style.\n\nReturn only a single JSON object with the key \\`\"suggestions\"\\` that maps to an array of suggestion objects.\n\nEach suggestion object must include:\n- \\`level\\`: 1, 2, or 3 (based on the categories above)\n- \\`start\\`: starting character index of the original substring (based on the exact input string, not tokens or words)\n- \\`end\\`: ending character index (exclusive)\n- \\`original\\`: the original substring in the text\n- \\`replacement\\`: your suggested alternative (optional for level 3)\n- \\`reason\\`: a short, clear explanation of the suggested improvement\n\nOutput **only** valid JSON. Do not include markdown, comments, or extra text.\n\nIf there are no issues, return:\n\\`\\`\\`json\n{ \"suggestions\": [] }\n\\`\\`\\``;\n\nexport const analyzeText = async (text: string, apiKey: string): Promise<OpenAIResponse> => {\n  if (!apiKey) {\n    throw new Error('OpenAI API key is required');\n  }\n\n  try {\n    const response = await fetch(OPENAI_API_URL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o',\n        messages: [\n          {\n            role: 'system',\n            content: SYSTEM_PROMPT,\n          },\n          {\n            role: 'user',\n            content: text,\n          },\n        ],\n        temperature: 0.3,\n        response_format: { type: 'json_object' },\n        max_tokens: 10000,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(`OpenAI API error: ${errorData.error?.message || 'Unknown error'}`);\n    }\n\n    const data = await response.json();\n\n    if (data.choices[0].finish_reason === 'length') {\n      throw new Error('The response was truncated because it exceeded the maximum token limit. Please try a shorter text.');\n    }\n    \n    const content = data.choices[0]?.message?.content;\n\n    if (!content) {\n      throw new Error('No response content from OpenAI');\n    }\n\n    // Content can be already an object when using JSON mode\n    if (typeof content === 'object') {\n      return content as OpenAIResponse;\n    }\n\n    // Fallback: try to parse string content\n    try {\n      const parsed = JSON.parse(content);\n      return parsed;\n    } catch (parseError) {\n      console.error('Failed to parse OpenAI response:', content);\n      throw new Error('Invalid JSON response from OpenAI');\n    }\n  } catch (error) {\n    console.error('Error calling OpenAI API:', error);\n    throw error;\n  }\n}; "],"mappings":"AAEA,MAAMA,cAAc,GAAG,4CAA4C;AAEnE,MAAMC,aAAa,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AAEP,OAAO,MAAMC,WAAW,GAAG,MAAAA,CAAOC,IAAY,EAAEC,MAAc,KAA8B;EAC1F,IAAI,CAACA,MAAM,EAAE;IACX,MAAM,IAAIC,KAAK,CAAC,4BAA4B,CAAC;EAC/C;EAEA,IAAI;IAAA,IAAAC,cAAA,EAAAC,qBAAA;IACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACT,cAAc,EAAE;MAC3CU,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACP,cAAc,EAAE,kBAAkB;QAClC,eAAe,EAAE,UAAUP,MAAM;MACnC,CAAC;MACDQ,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;QACnBC,KAAK,EAAE,QAAQ;QACfC,QAAQ,EAAE,CACR;UACEC,IAAI,EAAE,QAAQ;UACdC,OAAO,EAAEjB;QACX,CAAC,EACD;UACEgB,IAAI,EAAE,MAAM;UACZC,OAAO,EAAEf;QACX,CAAC,CACF;QACDgB,WAAW,EAAE,GAAG;QAChBC,eAAe,EAAE;UAAEC,IAAI,EAAE;QAAc,CAAC;QACxCC,UAAU,EAAE;MACd,CAAC;IACH,CAAC,CAAC;IAEF,IAAI,CAACd,QAAQ,CAACe,EAAE,EAAE;MAAA,IAAAC,gBAAA;MAChB,MAAMC,SAAS,GAAG,MAAMjB,QAAQ,CAACkB,IAAI,CAAC,CAAC;MACvC,MAAM,IAAIrB,KAAK,CAAC,qBAAqB,EAAAmB,gBAAA,GAAAC,SAAS,CAACE,KAAK,cAAAH,gBAAA,uBAAfA,gBAAA,CAAiBI,OAAO,KAAI,eAAe,EAAE,CAAC;IACrF;IAEA,MAAMC,IAAI,GAAG,MAAMrB,QAAQ,CAACkB,IAAI,CAAC,CAAC;IAElC,IAAIG,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC,CAACC,aAAa,KAAK,QAAQ,EAAE;MAC9C,MAAM,IAAI1B,KAAK,CAAC,oGAAoG,CAAC;IACvH;IAEA,MAAMa,OAAO,IAAAZ,cAAA,GAAGuB,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC,cAAAxB,cAAA,wBAAAC,qBAAA,GAAfD,cAAA,CAAiBsB,OAAO,cAAArB,qBAAA,uBAAxBA,qBAAA,CAA0BW,OAAO;IAEjD,IAAI,CAACA,OAAO,EAAE;MACZ,MAAM,IAAIb,KAAK,CAAC,iCAAiC,CAAC;IACpD;;IAEA;IACA,IAAI,OAAOa,OAAO,KAAK,QAAQ,EAAE;MAC/B,OAAOA,OAAO;IAChB;;IAEA;IACA,IAAI;MACF,MAAMc,MAAM,GAAGnB,IAAI,CAACoB,KAAK,CAACf,OAAO,CAAC;MAClC,OAAOc,MAAM;IACf,CAAC,CAAC,OAAOE,UAAU,EAAE;MACnBC,OAAO,CAACR,KAAK,CAAC,kCAAkC,EAAET,OAAO,CAAC;MAC1D,MAAM,IAAIb,KAAK,CAAC,mCAAmC,CAAC;IACtD;EACF,CAAC,CAAC,OAAOsB,KAAK,EAAE;IACdQ,OAAO,CAACR,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACjD,MAAMA,KAAK;EACb;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}