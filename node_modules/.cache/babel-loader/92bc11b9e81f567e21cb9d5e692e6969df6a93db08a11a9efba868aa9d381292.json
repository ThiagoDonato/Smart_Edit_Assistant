{"ast":null,"code":"import Diff from './base.js';\nimport { longestCommonPrefix, longestCommonSuffix, replacePrefix, replaceSuffix, removePrefix, removeSuffix, maximumOverlap, leadingWs, trailingWs } from '../util/string.js';\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nconst extendedWordChars = 'a-zA-Z0-9_\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}';\n// Each token is one of the following:\n// - A punctuation mark plus the surrounding whitespace\n// - A word plus the surrounding whitespace\n// - Pure whitespace (but only in the special case where this the entire text\n//   is just whitespace)\n//\n// We have to include surrounding whitespace in the tokens because the two\n// alternative approaches produce horribly broken results:\n// * If we just discard the whitespace, we can't fully reproduce the original\n//   text from the sequence of tokens and any attempt to render the diff will\n//   get the whitespace wrong.\n// * If we have separate tokens for whitespace, then in a typical text every\n//   second token will be a single space character. But this often results in\n//   the optimal diff between two texts being a perverse one that preserves\n//   the spaces between words but deletes and reinserts actual common words.\n//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n//   for an example.\n//\n// Keeping the surrounding whitespace of course has implications for .equals\n// and .join, not just .tokenize.\n// This regex does NOT fully implement the tokenization rules described above.\n// Instead, it gives runs of whitespace their own \"token\". The tokenize method\n// then handles stitching whitespace tokens onto adjacent word or punctuation\n// tokens.\nconst tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\\\s+|[^${extendedWordChars}]`, 'ug');\nclass WordDiff extends Diff {\n  equals(left, right, options) {\n    if (options.ignoreCase) {\n      left = left.toLowerCase();\n      right = right.toLowerCase();\n    }\n    return left.trim() === right.trim();\n  }\n  tokenize(value, options = {}) {\n    let parts;\n    if (options.intlSegmenter) {\n      const segmenter = options.intlSegmenter;\n      if (segmenter.resolvedOptions().granularity != 'word') {\n        throw new Error('The segmenter passed must have a granularity of \"word\"');\n      }\n      parts = Array.from(segmenter.segment(value), segment => segment.segment);\n    } else {\n      parts = value.match(tokenizeIncludingWhitespace) || [];\n    }\n    const tokens = [];\n    let prevPart = null;\n    parts.forEach(part => {\n      if (/\\s/.test(part)) {\n        if (prevPart == null) {\n          tokens.push(part);\n        } else {\n          tokens.push(tokens.pop() + part);\n        }\n      } else if (prevPart != null && /\\s/.test(prevPart)) {\n        if (tokens[tokens.length - 1] == prevPart) {\n          tokens.push(tokens.pop() + part);\n        } else {\n          tokens.push(prevPart + part);\n        }\n      } else {\n        tokens.push(part);\n      }\n      prevPart = part;\n    });\n    return tokens;\n  }\n  join(tokens) {\n    // Tokens being joined here will always have appeared consecutively in the\n    // same text, so we can simply strip off the leading whitespace from all the\n    // tokens except the first (and except any whitespace-only tokens - but such\n    // a token will always be the first and only token anyway) and then join them\n    // and the whitespace around words and punctuation will end up correct.\n    return tokens.map((token, i) => {\n      if (i == 0) {\n        return token;\n      } else {\n        return token.replace(/^\\s+/, '');\n      }\n    }).join('');\n  }\n  postProcess(changes, options) {\n    if (!changes || options.oneChangePerToken) {\n      return changes;\n    }\n    let lastKeep = null;\n    // Change objects representing any insertion or deletion since the last\n    // \"keep\" change object. There can be at most one of each.\n    let insertion = null;\n    let deletion = null;\n    changes.forEach(change => {\n      if (change.added) {\n        insertion = change;\n      } else if (change.removed) {\n        deletion = change;\n      } else {\n        if (insertion || deletion) {\n          // May be false at start of text\n          dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n        }\n        lastKeep = change;\n        insertion = null;\n        deletion = null;\n      }\n    });\n    if (insertion || deletion) {\n      dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n    }\n    return changes;\n  }\n}\nexport const wordDiff = new WordDiff();\nexport function diffWords(oldStr, newStr, options) {\n  // This option has never been documented and never will be (it's clearer to\n  // just call `diffWordsWithSpace` directly if you need that behavior), but\n  // has existed in jsdiff for a long time, so we retain support for it here\n  // for the sake of backwards compatibility.\n  if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {\n    return diffWordsWithSpace(oldStr, newStr, options);\n  }\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n  // Before returning, we tidy up the leading and trailing whitespace of the\n  // change objects to eliminate cases where trailing whitespace in one object\n  // is repeated as leading whitespace in the next.\n  // Below are examples of the outcomes we want here to explain the code.\n  // I=insert, K=keep, D=delete\n  // 1. diffing 'foo bar baz' vs 'foo baz'\n  //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n  //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n  //\n  // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n  //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n  //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n  //\n  // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n  //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n  //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n  //\n  // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n  //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n  //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n  //    but don't actually manage this currently (the pre-cleanup change\n  //    objects don't contain enough information to make it possible).\n  //\n  // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n  //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n  //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n  //\n  // Our handling is unavoidably imperfect in the case where there's a single\n  // indel between keeps and the whitespace has changed. For instance, consider\n  // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n  // object to represent the insertion of the space character (which isn't even\n  // a token), we have no way to avoid losing information about the texts'\n  // original whitespace in the result we return. Still, we do our best to\n  // output something that will look sensible if we e.g. print it with\n  // insertions in green and deletions in red.\n  // Between two \"keep\" change objects (or before the first or after the last\n  // change object), we can have either:\n  // * A \"delete\" followed by an \"insert\"\n  // * Just an \"insert\"\n  // * Just a \"delete\"\n  // We handle the three cases separately.\n  if (deletion && insertion) {\n    const oldWsPrefix = leadingWs(deletion.value);\n    const oldWsSuffix = trailingWs(deletion.value);\n    const newWsPrefix = leadingWs(insertion.value);\n    const newWsSuffix = trailingWs(insertion.value);\n    if (startKeep) {\n      const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n      deletion.value = removePrefix(deletion.value, commonWsPrefix);\n      insertion.value = removePrefix(insertion.value, commonWsPrefix);\n    }\n    if (endKeep) {\n      const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n      deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n      insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n    }\n  } else if (insertion) {\n    // The whitespaces all reflect what was in the new text rather than\n    // the old, so we essentially have no information about whitespace\n    // insertion or deletion. We just want to dedupe the whitespace.\n    // We do that by having each change object keep its trailing\n    // whitespace and deleting duplicate leading whitespace where\n    // present.\n    if (startKeep) {\n      const ws = leadingWs(insertion.value);\n      insertion.value = insertion.value.substring(ws.length);\n    }\n    if (endKeep) {\n      const ws = leadingWs(endKeep.value);\n      endKeep.value = endKeep.value.substring(ws.length);\n    }\n    // otherwise we've got a deletion and no insertion\n  } else if (startKeep && endKeep) {\n    const newWsFull = leadingWs(endKeep.value),\n      delWsStart = leadingWs(deletion.value),\n      delWsEnd = trailingWs(deletion.value);\n    // Any whitespace that comes straight after startKeep in both the old and\n    // new texts, assign to startKeep and remove from the deletion.\n    const newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n    deletion.value = removePrefix(deletion.value, newWsStart);\n    // Any whitespace that comes straight before endKeep in both the old and\n    // new texts, and hasn't already been assigned to startKeep, assign to\n    // endKeep and remove from the deletion.\n    const newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);\n    deletion.value = removeSuffix(deletion.value, newWsEnd);\n    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n    // If there's any whitespace from the new text that HASN'T already been\n    // assigned, assign it to the start:\n    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));\n  } else if (endKeep) {\n    // We are at the start of the text. Preserve all the whitespace on\n    // endKeep, and just remove whitespace from the end of deletion to the\n    // extent that it overlaps with the start of endKeep.\n    const endKeepWsPrefix = leadingWs(endKeep.value);\n    const deletionWsSuffix = trailingWs(deletion.value);\n    const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n    deletion.value = removeSuffix(deletion.value, overlap);\n  } else if (startKeep) {\n    // We are at the END of the text. Preserve all the whitespace on\n    // startKeep, and just remove whitespace from the start of deletion to\n    // the extent that it overlaps with the end of startKeep.\n    const startKeepWsSuffix = trailingWs(startKeep.value);\n    const deletionWsPrefix = leadingWs(deletion.value);\n    const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n    deletion.value = removePrefix(deletion.value, overlap);\n  }\n}\nclass WordsWithSpaceDiff extends Diff {\n  tokenize(value) {\n    // Slightly different to the tokenizeIncludingWhitespace regex used above in\n    // that this one treats each individual newline as a distinct tokens, rather\n    // than merging them into other surrounding whitespace. This was requested\n    // in https://github.com/kpdecker/jsdiff/issues/180 &\n    //    https://github.com/kpdecker/jsdiff/issues/211\n    const regex = new RegExp(`(\\\\r?\\\\n)|[${extendedWordChars}]+|[^\\\\S\\\\n\\\\r]+|[^${extendedWordChars}]`, 'ug');\n    return value.match(regex) || [];\n  }\n}\nexport const wordsWithSpaceDiff = new WordsWithSpaceDiff();\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n  return wordsWithSpaceDiff.diff(oldStr, newStr, options);\n}","map":{"version":3,"names":["Diff","longestCommonPrefix","longestCommonSuffix","replacePrefix","replaceSuffix","removePrefix","removeSuffix","maximumOverlap","leadingWs","trailingWs","extendedWordChars","tokenizeIncludingWhitespace","RegExp","WordDiff","equals","left","right","options","ignoreCase","toLowerCase","trim","tokenize","value","parts","intlSegmenter","segmenter","resolvedOptions","granularity","Error","Array","from","segment","match","tokens","prevPart","forEach","part","test","push","pop","length","join","map","token","i","replace","postProcess","changes","oneChangePerToken","lastKeep","insertion","deletion","change","added","removed","dedupeWhitespaceInChangeObjects","wordDiff","diffWords","oldStr","newStr","ignoreWhitespace","diffWordsWithSpace","diff","startKeep","endKeep","oldWsPrefix","oldWsSuffix","newWsPrefix","newWsSuffix","commonWsPrefix","commonWsSuffix","ws","substring","newWsFull","delWsStart","delWsEnd","newWsStart","newWsEnd","slice","endKeepWsPrefix","deletionWsSuffix","overlap","startKeepWsSuffix","deletionWsPrefix","WordsWithSpaceDiff","regex","wordsWithSpaceDiff"],"sources":["/Users/thiagodonato/Documents/App_Projects/Edit_Text/node_modules/diff/libesm/diff/word.js"],"sourcesContent":["import Diff from './base.js';\nimport { longestCommonPrefix, longestCommonSuffix, replacePrefix, replaceSuffix, removePrefix, removeSuffix, maximumOverlap, leadingWs, trailingWs } from '../util/string.js';\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nconst extendedWordChars = 'a-zA-Z0-9_\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}';\n// Each token is one of the following:\n// - A punctuation mark plus the surrounding whitespace\n// - A word plus the surrounding whitespace\n// - Pure whitespace (but only in the special case where this the entire text\n//   is just whitespace)\n//\n// We have to include surrounding whitespace in the tokens because the two\n// alternative approaches produce horribly broken results:\n// * If we just discard the whitespace, we can't fully reproduce the original\n//   text from the sequence of tokens and any attempt to render the diff will\n//   get the whitespace wrong.\n// * If we have separate tokens for whitespace, then in a typical text every\n//   second token will be a single space character. But this often results in\n//   the optimal diff between two texts being a perverse one that preserves\n//   the spaces between words but deletes and reinserts actual common words.\n//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n//   for an example.\n//\n// Keeping the surrounding whitespace of course has implications for .equals\n// and .join, not just .tokenize.\n// This regex does NOT fully implement the tokenization rules described above.\n// Instead, it gives runs of whitespace their own \"token\". The tokenize method\n// then handles stitching whitespace tokens onto adjacent word or punctuation\n// tokens.\nconst tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\\\s+|[^${extendedWordChars}]`, 'ug');\nclass WordDiff extends Diff {\n    equals(left, right, options) {\n        if (options.ignoreCase) {\n            left = left.toLowerCase();\n            right = right.toLowerCase();\n        }\n        return left.trim() === right.trim();\n    }\n    tokenize(value, options = {}) {\n        let parts;\n        if (options.intlSegmenter) {\n            const segmenter = options.intlSegmenter;\n            if (segmenter.resolvedOptions().granularity != 'word') {\n                throw new Error('The segmenter passed must have a granularity of \"word\"');\n            }\n            parts = Array.from(segmenter.segment(value), segment => segment.segment);\n        }\n        else {\n            parts = value.match(tokenizeIncludingWhitespace) || [];\n        }\n        const tokens = [];\n        let prevPart = null;\n        parts.forEach(part => {\n            if ((/\\s/).test(part)) {\n                if (prevPart == null) {\n                    tokens.push(part);\n                }\n                else {\n                    tokens.push(tokens.pop() + part);\n                }\n            }\n            else if (prevPart != null && (/\\s/).test(prevPart)) {\n                if (tokens[tokens.length - 1] == prevPart) {\n                    tokens.push(tokens.pop() + part);\n                }\n                else {\n                    tokens.push(prevPart + part);\n                }\n            }\n            else {\n                tokens.push(part);\n            }\n            prevPart = part;\n        });\n        return tokens;\n    }\n    join(tokens) {\n        // Tokens being joined here will always have appeared consecutively in the\n        // same text, so we can simply strip off the leading whitespace from all the\n        // tokens except the first (and except any whitespace-only tokens - but such\n        // a token will always be the first and only token anyway) and then join them\n        // and the whitespace around words and punctuation will end up correct.\n        return tokens.map((token, i) => {\n            if (i == 0) {\n                return token;\n            }\n            else {\n                return token.replace((/^\\s+/), '');\n            }\n        }).join('');\n    }\n    postProcess(changes, options) {\n        if (!changes || options.oneChangePerToken) {\n            return changes;\n        }\n        let lastKeep = null;\n        // Change objects representing any insertion or deletion since the last\n        // \"keep\" change object. There can be at most one of each.\n        let insertion = null;\n        let deletion = null;\n        changes.forEach(change => {\n            if (change.added) {\n                insertion = change;\n            }\n            else if (change.removed) {\n                deletion = change;\n            }\n            else {\n                if (insertion || deletion) { // May be false at start of text\n                    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n                }\n                lastKeep = change;\n                insertion = null;\n                deletion = null;\n            }\n        });\n        if (insertion || deletion) {\n            dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n        }\n        return changes;\n    }\n}\nexport const wordDiff = new WordDiff();\nexport function diffWords(oldStr, newStr, options) {\n    // This option has never been documented and never will be (it's clearer to\n    // just call `diffWordsWithSpace` directly if you need that behavior), but\n    // has existed in jsdiff for a long time, so we retain support for it here\n    // for the sake of backwards compatibility.\n    if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {\n        return diffWordsWithSpace(oldStr, newStr, options);\n    }\n    return wordDiff.diff(oldStr, newStr, options);\n}\nfunction dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n    // Before returning, we tidy up the leading and trailing whitespace of the\n    // change objects to eliminate cases where trailing whitespace in one object\n    // is repeated as leading whitespace in the next.\n    // Below are examples of the outcomes we want here to explain the code.\n    // I=insert, K=keep, D=delete\n    // 1. diffing 'foo bar baz' vs 'foo baz'\n    //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n    //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n    //\n    // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n    //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n    //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n    //\n    // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n    //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n    //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n    //\n    // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n    //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n    //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n    //    but don't actually manage this currently (the pre-cleanup change\n    //    objects don't contain enough information to make it possible).\n    //\n    // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n    //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n    //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n    //\n    // Our handling is unavoidably imperfect in the case where there's a single\n    // indel between keeps and the whitespace has changed. For instance, consider\n    // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n    // object to represent the insertion of the space character (which isn't even\n    // a token), we have no way to avoid losing information about the texts'\n    // original whitespace in the result we return. Still, we do our best to\n    // output something that will look sensible if we e.g. print it with\n    // insertions in green and deletions in red.\n    // Between two \"keep\" change objects (or before the first or after the last\n    // change object), we can have either:\n    // * A \"delete\" followed by an \"insert\"\n    // * Just an \"insert\"\n    // * Just a \"delete\"\n    // We handle the three cases separately.\n    if (deletion && insertion) {\n        const oldWsPrefix = leadingWs(deletion.value);\n        const oldWsSuffix = trailingWs(deletion.value);\n        const newWsPrefix = leadingWs(insertion.value);\n        const newWsSuffix = trailingWs(insertion.value);\n        if (startKeep) {\n            const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n            startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n            deletion.value = removePrefix(deletion.value, commonWsPrefix);\n            insertion.value = removePrefix(insertion.value, commonWsPrefix);\n        }\n        if (endKeep) {\n            const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n            endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n            deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n            insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n        }\n    }\n    else if (insertion) {\n        // The whitespaces all reflect what was in the new text rather than\n        // the old, so we essentially have no information about whitespace\n        // insertion or deletion. We just want to dedupe the whitespace.\n        // We do that by having each change object keep its trailing\n        // whitespace and deleting duplicate leading whitespace where\n        // present.\n        if (startKeep) {\n            const ws = leadingWs(insertion.value);\n            insertion.value = insertion.value.substring(ws.length);\n        }\n        if (endKeep) {\n            const ws = leadingWs(endKeep.value);\n            endKeep.value = endKeep.value.substring(ws.length);\n        }\n        // otherwise we've got a deletion and no insertion\n    }\n    else if (startKeep && endKeep) {\n        const newWsFull = leadingWs(endKeep.value), delWsStart = leadingWs(deletion.value), delWsEnd = trailingWs(deletion.value);\n        // Any whitespace that comes straight after startKeep in both the old and\n        // new texts, assign to startKeep and remove from the deletion.\n        const newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n        deletion.value = removePrefix(deletion.value, newWsStart);\n        // Any whitespace that comes straight before endKeep in both the old and\n        // new texts, and hasn't already been assigned to startKeep, assign to\n        // endKeep and remove from the deletion.\n        const newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);\n        deletion.value = removeSuffix(deletion.value, newWsEnd);\n        endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n        // If there's any whitespace from the new text that HASN'T already been\n        // assigned, assign it to the start:\n        startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));\n    }\n    else if (endKeep) {\n        // We are at the start of the text. Preserve all the whitespace on\n        // endKeep, and just remove whitespace from the end of deletion to the\n        // extent that it overlaps with the start of endKeep.\n        const endKeepWsPrefix = leadingWs(endKeep.value);\n        const deletionWsSuffix = trailingWs(deletion.value);\n        const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n        deletion.value = removeSuffix(deletion.value, overlap);\n    }\n    else if (startKeep) {\n        // We are at the END of the text. Preserve all the whitespace on\n        // startKeep, and just remove whitespace from the start of deletion to\n        // the extent that it overlaps with the end of startKeep.\n        const startKeepWsSuffix = trailingWs(startKeep.value);\n        const deletionWsPrefix = leadingWs(deletion.value);\n        const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n        deletion.value = removePrefix(deletion.value, overlap);\n    }\n}\nclass WordsWithSpaceDiff extends Diff {\n    tokenize(value) {\n        // Slightly different to the tokenizeIncludingWhitespace regex used above in\n        // that this one treats each individual newline as a distinct tokens, rather\n        // than merging them into other surrounding whitespace. This was requested\n        // in https://github.com/kpdecker/jsdiff/issues/180 &\n        //    https://github.com/kpdecker/jsdiff/issues/211\n        const regex = new RegExp(`(\\\\r?\\\\n)|[${extendedWordChars}]+|[^\\\\S\\\\n\\\\r]+|[^${extendedWordChars}]`, 'ug');\n        return value.match(regex) || [];\n    }\n}\nexport const wordsWithSpaceDiff = new WordsWithSpaceDiff();\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordsWithSpaceDiff.diff(oldStr, newStr, options);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}