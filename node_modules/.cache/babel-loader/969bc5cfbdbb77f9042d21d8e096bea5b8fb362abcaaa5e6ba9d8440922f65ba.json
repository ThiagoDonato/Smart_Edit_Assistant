{"ast":null,"code":"export function longestCommonPrefix(str1, str2) {\n  let i;\n  for (i = 0; i < str1.length && i < str2.length; i++) {\n    if (str1[i] != str2[i]) {\n      return str1.slice(0, i);\n    }\n  }\n  return str1.slice(0, i);\n}\nexport function longestCommonSuffix(str1, str2) {\n  let i;\n  // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n  // where we return the empty string since str1.slice(-0) will return the\n  // entire string.\n  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n    return '';\n  }\n  for (i = 0; i < str1.length && i < str2.length; i++) {\n    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n      return str1.slice(-i);\n    }\n  }\n  return str1.slice(-i);\n}\nexport function replacePrefix(string, oldPrefix, newPrefix) {\n  if (string.slice(0, oldPrefix.length) != oldPrefix) {\n    throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);\n  }\n  return newPrefix + string.slice(oldPrefix.length);\n}\nexport function replaceSuffix(string, oldSuffix, newSuffix) {\n  if (!oldSuffix) {\n    return string + newSuffix;\n  }\n  if (string.slice(-oldSuffix.length) != oldSuffix) {\n    throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);\n  }\n  return string.slice(0, -oldSuffix.length) + newSuffix;\n}\nexport function removePrefix(string, oldPrefix) {\n  return replacePrefix(string, oldPrefix, '');\n}\nexport function removeSuffix(string, oldSuffix) {\n  return replaceSuffix(string, oldSuffix, '');\n}\nexport function maximumOverlap(string1, string2) {\n  return string2.slice(0, overlapCount(string1, string2));\n}\n// Nicked from https://stackoverflow.com/a/60422853/1709587\nfunction overlapCount(a, b) {\n  // Deal with cases where the strings differ in length\n  let startA = 0;\n  if (a.length > b.length) {\n    startA = a.length - b.length;\n  }\n  let endB = b.length;\n  if (a.length < b.length) {\n    endB = a.length;\n  }\n  // Create a back-reference for each index\n  //   that should be followed in case of a mismatch.\n  //   We only need B to make these references:\n  const map = Array(endB);\n  let k = 0; // Index that lags behind j\n  map[0] = 0;\n  for (let j = 1; j < endB; j++) {\n    if (b[j] == b[k]) {\n      map[j] = map[k]; // skip over the same character (optional optimisation)\n    } else {\n      map[j] = k;\n    }\n    while (k > 0 && b[j] != b[k]) {\n      k = map[k];\n    }\n    if (b[j] == b[k]) {\n      k++;\n    }\n  }\n  // Phase 2: use these references while iterating over A\n  k = 0;\n  for (let i = startA; i < a.length; i++) {\n    while (k > 0 && a[i] != b[k]) {\n      k = map[k];\n    }\n    if (a[i] == b[k]) {\n      k++;\n    }\n  }\n  return k;\n}\n/**\n * Returns true if the string consistently uses Windows line endings.\n */\nexport function hasOnlyWinLineEndings(string) {\n  return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n}\n/**\n * Returns true if the string consistently uses Unix line endings.\n */\nexport function hasOnlyUnixLineEndings(string) {\n  return !string.includes('\\r\\n') && string.includes('\\n');\n}\nexport function trailingWs(string) {\n  // Yes, this looks overcomplicated and dumb - why not replace the whole function with\n  //     return string match(/\\s*$/)[0]\n  // you ask? Because:\n  // 1. the trap described at https://markamery.com/blog/quadratic-time-regexes/ would mean doing\n  //    this would cause this function to take O(n²) time in the worst case (specifically when\n  //    there is a massive run of NON-TRAILING whitespace in `string`), and\n  // 2. the fix proposed in the same blog post, of using a negative lookbehind, is incompatible\n  //    with old Safari versions that we'd like to not break if possible (see\n  //    https://github.com/kpdecker/jsdiff/pull/550)\n  // It feels absurd to do this with an explicit loop instead of a regex, but I really can't see a\n  // better way that doesn't result in broken behaviour.\n  let i;\n  for (i = string.length - 1; i >= 0; i--) {\n    if (!string[i].match(/\\s/)) {\n      break;\n    }\n  }\n  return string.substring(i + 1);\n}\nexport function leadingWs(string) {\n  // Thankfully the annoying considerations described in trailingWs don't apply here:\n  const match = string.match(/^\\s*/);\n  return match ? match[0] : '';\n}","map":{"version":3,"names":["longestCommonPrefix","str1","str2","i","length","slice","longestCommonSuffix","replacePrefix","string","oldPrefix","newPrefix","Error","JSON","stringify","replaceSuffix","oldSuffix","newSuffix","removePrefix","removeSuffix","maximumOverlap","string1","string2","overlapCount","a","b","startA","endB","map","Array","k","j","hasOnlyWinLineEndings","includes","startsWith","match","hasOnlyUnixLineEndings","trailingWs","substring","leadingWs"],"sources":["/Users/thiagodonato/Documents/App_Projects/Edit_Text/node_modules/diff/libesm/util/string.js"],"sourcesContent":["export function longestCommonPrefix(str1, str2) {\n    let i;\n    for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[i] != str2[i]) {\n            return str1.slice(0, i);\n        }\n    }\n    return str1.slice(0, i);\n}\nexport function longestCommonSuffix(str1, str2) {\n    let i;\n    // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n    // where we return the empty string since str1.slice(-0) will return the\n    // entire string.\n    if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n        return '';\n    }\n    for (i = 0; i < str1.length && i < str2.length; i++) {\n        if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n            return str1.slice(-i);\n        }\n    }\n    return str1.slice(-i);\n}\nexport function replacePrefix(string, oldPrefix, newPrefix) {\n    if (string.slice(0, oldPrefix.length) != oldPrefix) {\n        throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);\n    }\n    return newPrefix + string.slice(oldPrefix.length);\n}\nexport function replaceSuffix(string, oldSuffix, newSuffix) {\n    if (!oldSuffix) {\n        return string + newSuffix;\n    }\n    if (string.slice(-oldSuffix.length) != oldSuffix) {\n        throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);\n    }\n    return string.slice(0, -oldSuffix.length) + newSuffix;\n}\nexport function removePrefix(string, oldPrefix) {\n    return replacePrefix(string, oldPrefix, '');\n}\nexport function removeSuffix(string, oldSuffix) {\n    return replaceSuffix(string, oldSuffix, '');\n}\nexport function maximumOverlap(string1, string2) {\n    return string2.slice(0, overlapCount(string1, string2));\n}\n// Nicked from https://stackoverflow.com/a/60422853/1709587\nfunction overlapCount(a, b) {\n    // Deal with cases where the strings differ in length\n    let startA = 0;\n    if (a.length > b.length) {\n        startA = a.length - b.length;\n    }\n    let endB = b.length;\n    if (a.length < b.length) {\n        endB = a.length;\n    }\n    // Create a back-reference for each index\n    //   that should be followed in case of a mismatch.\n    //   We only need B to make these references:\n    const map = Array(endB);\n    let k = 0; // Index that lags behind j\n    map[0] = 0;\n    for (let j = 1; j < endB; j++) {\n        if (b[j] == b[k]) {\n            map[j] = map[k]; // skip over the same character (optional optimisation)\n        }\n        else {\n            map[j] = k;\n        }\n        while (k > 0 && b[j] != b[k]) {\n            k = map[k];\n        }\n        if (b[j] == b[k]) {\n            k++;\n        }\n    }\n    // Phase 2: use these references while iterating over A\n    k = 0;\n    for (let i = startA; i < a.length; i++) {\n        while (k > 0 && a[i] != b[k]) {\n            k = map[k];\n        }\n        if (a[i] == b[k]) {\n            k++;\n        }\n    }\n    return k;\n}\n/**\n * Returns true if the string consistently uses Windows line endings.\n */\nexport function hasOnlyWinLineEndings(string) {\n    return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n}\n/**\n * Returns true if the string consistently uses Unix line endings.\n */\nexport function hasOnlyUnixLineEndings(string) {\n    return !string.includes('\\r\\n') && string.includes('\\n');\n}\nexport function trailingWs(string) {\n    // Yes, this looks overcomplicated and dumb - why not replace the whole function with\n    //     return string match(/\\s*$/)[0]\n    // you ask? Because:\n    // 1. the trap described at https://markamery.com/blog/quadratic-time-regexes/ would mean doing\n    //    this would cause this function to take O(n²) time in the worst case (specifically when\n    //    there is a massive run of NON-TRAILING whitespace in `string`), and\n    // 2. the fix proposed in the same blog post, of using a negative lookbehind, is incompatible\n    //    with old Safari versions that we'd like to not break if possible (see\n    //    https://github.com/kpdecker/jsdiff/pull/550)\n    // It feels absurd to do this with an explicit loop instead of a regex, but I really can't see a\n    // better way that doesn't result in broken behaviour.\n    let i;\n    for (i = string.length - 1; i >= 0; i--) {\n        if (!string[i].match(/\\s/)) {\n            break;\n        }\n    }\n    return string.substring(i + 1);\n}\nexport function leadingWs(string) {\n    // Thankfully the annoying considerations described in trailingWs don't apply here:\n    const match = string.match(/^\\s*/);\n    return match ? match[0] : '';\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}