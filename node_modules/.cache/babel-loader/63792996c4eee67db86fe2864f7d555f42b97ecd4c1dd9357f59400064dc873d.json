{"ast":null,"code":"export const processTextWithSuggestions = (text, suggestions) => {\n  if (!suggestions || !suggestions.length) {\n    return [{\n      text,\n      isHighlighted: false\n    }];\n  }\n  const spans = [];\n  let lastIndex = 0;\n  let searchFromIndex = 0;\n  suggestions.forEach(suggestion => {\n    const {\n      original\n    } = suggestion;\n    if (!original) return;\n\n    // Find the start index of the original text, starting from where the last match ended.\n    const startIndex = text.indexOf(original, searchFromIndex);\n    if (startIndex === -1) {\n      console.warn(`Could not find original text from suggestion: \"${original}\"`);\n      return; // Skips to the next suggestion\n    }\n    const endIndex = startIndex + original.length;\n\n    // 1. Add the text segment *before* the current match\n    if (startIndex > lastIndex) {\n      spans.push({\n        text: text.slice(lastIndex, startIndex),\n        isHighlighted: false\n      });\n    }\n\n    // 2. Add the highlighted segment\n    spans.push({\n      text: text.slice(startIndex, endIndex),\n      suggestion: suggestion,\n      isHighlighted: true\n    });\n\n    // 3. Update indices for the next iteration\n    lastIndex = endIndex;\n    searchFromIndex = endIndex;\n  });\n\n  // Add any remaining text after the last suggestion\n  if (lastIndex < text.length) {\n    spans.push({\n      text: text.slice(lastIndex),\n      isHighlighted: false\n    });\n  }\n  return spans;\n};\nexport const getLevelClassName = level => {\n  switch (level) {\n    case 1:\n      return 'highlight-level-1';\n    case 2:\n      return 'highlight-level-2';\n    case 3:\n      return 'highlight-level-3';\n    default:\n      return '';\n  }\n};\nexport const getLevelColor = level => {\n  switch (level) {\n    case 1:\n      return 'text-blue-600';\n    case 2:\n      return 'text-yellow-600';\n    case 3:\n      return 'text-red-600';\n    default:\n      return '';\n  }\n};\nexport const getLevelLabel = level => {\n  switch (level) {\n    case 1:\n      return 'Grammar';\n    case 2:\n      return 'Structure';\n    case 3:\n      return 'Content';\n    default:\n      return '';\n  }\n};\nexport const highlightTextWithSuggestions = processTextWithSuggestions;","map":{"version":3,"names":["processTextWithSuggestions","text","suggestions","length","isHighlighted","spans","lastIndex","searchFromIndex","forEach","suggestion","original","startIndex","indexOf","console","warn","endIndex","push","slice","getLevelClassName","level","getLevelColor","getLevelLabel","highlightTextWithSuggestions"],"sources":["/Users/thiagodonato/Documents/App_Projects/Edit_Text/src/utils.ts"],"sourcesContent":["import { Suggestion, HighlightSpan } from './types';\n\nexport const processTextWithSuggestions = (text: string, suggestions: Suggestion[]): HighlightSpan[] => {\n  if (!suggestions || !suggestions.length) {\n    return [{ text, isHighlighted: false }];\n  }\n\n  const spans: HighlightSpan[] = [];\n  let lastIndex = 0;\n  let searchFromIndex = 0;\n\n  suggestions.forEach((suggestion) => {\n    const { original } = suggestion;\n\n    if (!original) return;\n\n    // Find the start index of the original text, starting from where the last match ended.\n    const startIndex = text.indexOf(original, searchFromIndex);\n\n    if (startIndex === -1) {\n      console.warn(`Could not find original text from suggestion: \"${original}\"`);\n      return; // Skips to the next suggestion\n    }\n\n    const endIndex = startIndex + original.length;\n\n    // 1. Add the text segment *before* the current match\n    if (startIndex > lastIndex) {\n      spans.push({\n        text: text.slice(lastIndex, startIndex),\n        isHighlighted: false,\n      });\n    }\n\n    // 2. Add the highlighted segment\n    spans.push({\n      text: text.slice(startIndex, endIndex),\n      suggestion: suggestion,\n      isHighlighted: true,\n    });\n\n    // 3. Update indices for the next iteration\n    lastIndex = endIndex;\n    searchFromIndex = endIndex;\n  });\n\n  // Add any remaining text after the last suggestion\n  if (lastIndex < text.length) {\n    spans.push({\n      text: text.slice(lastIndex),\n      isHighlighted: false,\n    });\n  }\n\n  return spans;\n};\n\nexport const getLevelClassName = (level: 1 | 2 | 3): string => {\n  switch (level) {\n    case 1:\n      return 'highlight-level-1';\n    case 2:\n      return 'highlight-level-2';\n    case 3:\n      return 'highlight-level-3';\n    default:\n      return '';\n  }\n};\n\nexport const getLevelColor = (level: 1 | 2 | 3): string => {\n  switch (level) {\n    case 1:\n      return 'text-blue-600';\n    case 2:\n      return 'text-yellow-600';\n    case 3:\n      return 'text-red-600';\n    default:\n      return '';\n  }\n};\n\nexport const getLevelLabel = (level: 1 | 2 | 3): string => {\n  switch (level) {\n    case 1:\n      return 'Grammar';\n    case 2:\n      return 'Structure';\n    case 3:\n      return 'Content';\n    default:\n      return '';\n  }\n};\n\nexport const highlightTextWithSuggestions = processTextWithSuggestions; "],"mappings":"AAEA,OAAO,MAAMA,0BAA0B,GAAGA,CAACC,IAAY,EAAEC,WAAyB,KAAsB;EACtG,IAAI,CAACA,WAAW,IAAI,CAACA,WAAW,CAACC,MAAM,EAAE;IACvC,OAAO,CAAC;MAAEF,IAAI;MAAEG,aAAa,EAAE;IAAM,CAAC,CAAC;EACzC;EAEA,MAAMC,KAAsB,GAAG,EAAE;EACjC,IAAIC,SAAS,GAAG,CAAC;EACjB,IAAIC,eAAe,GAAG,CAAC;EAEvBL,WAAW,CAACM,OAAO,CAAEC,UAAU,IAAK;IAClC,MAAM;MAAEC;IAAS,CAAC,GAAGD,UAAU;IAE/B,IAAI,CAACC,QAAQ,EAAE;;IAEf;IACA,MAAMC,UAAU,GAAGV,IAAI,CAACW,OAAO,CAACF,QAAQ,EAAEH,eAAe,CAAC;IAE1D,IAAII,UAAU,KAAK,CAAC,CAAC,EAAE;MACrBE,OAAO,CAACC,IAAI,CAAC,kDAAkDJ,QAAQ,GAAG,CAAC;MAC3E,OAAO,CAAC;IACV;IAEA,MAAMK,QAAQ,GAAGJ,UAAU,GAAGD,QAAQ,CAACP,MAAM;;IAE7C;IACA,IAAIQ,UAAU,GAAGL,SAAS,EAAE;MAC1BD,KAAK,CAACW,IAAI,CAAC;QACTf,IAAI,EAAEA,IAAI,CAACgB,KAAK,CAACX,SAAS,EAAEK,UAAU,CAAC;QACvCP,aAAa,EAAE;MACjB,CAAC,CAAC;IACJ;;IAEA;IACAC,KAAK,CAACW,IAAI,CAAC;MACTf,IAAI,EAAEA,IAAI,CAACgB,KAAK,CAACN,UAAU,EAAEI,QAAQ,CAAC;MACtCN,UAAU,EAAEA,UAAU;MACtBL,aAAa,EAAE;IACjB,CAAC,CAAC;;IAEF;IACAE,SAAS,GAAGS,QAAQ;IACpBR,eAAe,GAAGQ,QAAQ;EAC5B,CAAC,CAAC;;EAEF;EACA,IAAIT,SAAS,GAAGL,IAAI,CAACE,MAAM,EAAE;IAC3BE,KAAK,CAACW,IAAI,CAAC;MACTf,IAAI,EAAEA,IAAI,CAACgB,KAAK,CAACX,SAAS,CAAC;MAC3BF,aAAa,EAAE;IACjB,CAAC,CAAC;EACJ;EAEA,OAAOC,KAAK;AACd,CAAC;AAED,OAAO,MAAMa,iBAAiB,GAAIC,KAAgB,IAAa;EAC7D,QAAQA,KAAK;IACX,KAAK,CAAC;MACJ,OAAO,mBAAmB;IAC5B,KAAK,CAAC;MACJ,OAAO,mBAAmB;IAC5B,KAAK,CAAC;MACJ,OAAO,mBAAmB;IAC5B;MACE,OAAO,EAAE;EACb;AACF,CAAC;AAED,OAAO,MAAMC,aAAa,GAAID,KAAgB,IAAa;EACzD,QAAQA,KAAK;IACX,KAAK,CAAC;MACJ,OAAO,eAAe;IACxB,KAAK,CAAC;MACJ,OAAO,iBAAiB;IAC1B,KAAK,CAAC;MACJ,OAAO,cAAc;IACvB;MACE,OAAO,EAAE;EACb;AACF,CAAC;AAED,OAAO,MAAME,aAAa,GAAIF,KAAgB,IAAa;EACzD,QAAQA,KAAK;IACX,KAAK,CAAC;MACJ,OAAO,SAAS;IAClB,KAAK,CAAC;MACJ,OAAO,WAAW;IACpB,KAAK,CAAC;MACJ,OAAO,SAAS;IAClB;MACE,OAAO,EAAE;EACb;AACF,CAAC;AAED,OAAO,MAAMG,4BAA4B,GAAGtB,0BAA0B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}